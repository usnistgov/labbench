from threading import ThreadError
from typing import Any, Callable

import_t0: Any
logger: Any

class LabbenchDeprecationWarning(DeprecationWarning): ...

def show_messages(minimum_level, colors: bool = ...) -> None: ...

class Ownable:
    __objclass__: Any
    def __init__(self) -> None: ...
    __name__: Any
    def __set_name__(self, owner_cls, name) -> None: ...
    def __get__(self, owner, owner_cls: Any | None = ...): ...
    def __owner_init__(self, owner) -> None: ...
    def __owner_subclass__(self, owner_cls): ...

class ConcurrentException(Exception): ...
class OwnerThreadException(ThreadError): ...
class ThreadEndedByMaster(ThreadError): ...

def hide_in_traceback(func): ...

class _filtered_exc_info:
    lb_wrapped: Any
    def __init__(self, wrapped) -> None: ...
    def __call__(self): ...

def sleep(seconds, tick: float = ...) -> None: ...
def check_hanging_thread() -> None: ...
def retry(
    exception_or_exceptions,
    tries: int = ...,
    delay: int = ...,
    backoff: int = ...,
    exception_func=...,
): ...
def until_timeout(
    exception_or_exceptions,
    timeout,
    delay: int = ...,
    backoff: int = ...,
    exception_func=...,
): ...
def kill_by_name(*names) -> None: ...
def hash_caller(call_depth: int = ...): ...
def stopwatch(desc: str = ..., threshold: float = ...): ...

class Call:
    func: Any
    name: Any
    args: Any
    kws: Any
    queue: Any
    def __init__(self, func, *args, **kws) -> None: ...
    result: Any
    traceback: Any
    def __call__(self): ...
    def set_queue(self, queue) -> None: ...
    @classmethod
    def wrap_list_to_dict(cls, name_func_pairs): ...

class MultipleContexts:
    abort: bool
    __name__: str
    objs: Any
    params: Any
    call_handler: Any
    exc: Any
    def __init__(
        self, call_handler: Callable[[dict, list, dict], dict], params: dict, objs: list
    ) -> None: ...
    def enter(self, name, context) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *exc) -> None: ...

def concurrently(*objs, **kws): ...
def sequentially(*objs, **kws): ...

class ThreadDelegate:
    def __init__(self, sandbox, obj, dir_, repr_) -> None: ...
    def __call__(self, *args, **kws): ...
    def __getattribute__(self, name): ...
    def __dir__(self): ...
    def __setattr__(self, name, value): ...

class ThreadSandbox:
    __repr_root__: str
    __dir_root__: Any
    def __init__(self, factory, should_sandbox_func: Any | None = ...) -> None: ...
    def __getattr__(self, name): ...
    def __setattr__(self, name, value): ...
    def __del__(self) -> None: ...
    def __dir__(self): ...

class ConfigStore:
    @classmethod
    def all(cls): ...
    @classmethod
    def frame(cls): ...

# Names in __all__ with no definition:
#   _force_full_traceback
#   timeout_itercopy_func
