from _typeshed import Incomplete
from collections.abc import Generator
from threading import ThreadError
from typing import Callable

import_t0: Incomplete
logger: Incomplete

class LabbenchDeprecationWarning(DeprecationWarning): ...

def show_messages(minimum_level, colors: bool = ...) -> None: ...

class Ownable:
    __objclass__: Incomplete
    def __init__(self) -> None: ...
    __name__: Incomplete
    def __set_name__(self, owner_cls, name) -> None: ...
    def __get__(self, owner, owner_cls: Incomplete | None = ...): ...
    def __owner_init__(self, owner) -> None: ...
    def __owner_subclass__(self, owner_cls): ...

class ConcurrentException(Exception):
    thread_exceptions: Incomplete

class OwnerThreadException(ThreadError): ...
class ThreadEndedByMaster(ThreadError): ...

def hide_in_traceback(func): ...

class _filtered_exc_info:
    lb_wrapped: Incomplete
    def __init__(self, wrapped) -> None: ...
    def __call__(self): ...

def copy_func(func, assigned=..., updated=...) -> callable: ...
def sleep(seconds, tick: float = ...) -> None: ...
def check_hanging_thread() -> None: ...
def retry(
    exception_or_exceptions,
    tries: int = ...,
    delay: int = ...,
    backoff: int = ...,
    exception_func=...,
): ...
def until_timeout(
    exception_or_exceptions,
    timeout,
    delay: int = ...,
    backoff: int = ...,
    exception_func=...,
): ...
def timeout_iter(duration) -> Generator[Incomplete, None, None]: ...
def kill_by_name(*names) -> None: ...
def hash_caller(call_depth: int = ...): ...
def stopwatch(desc: str = ..., threshold: float = ...): ...

class Call:
    func: Incomplete
    name: Incomplete
    args: Incomplete
    kws: Incomplete
    queue: Incomplete
    def __init__(self, func, *args, **kws) -> None: ...
    def rename(self, name): ...
    result: Incomplete
    traceback: Incomplete
    def __call__(self): ...
    def set_queue(self, queue) -> None: ...
    @classmethod
    def wrap_list_to_dict(cls, name_func_pairs): ...

class MultipleContexts:
    abort: bool
    __name__: str
    objs: Incomplete
    params: Incomplete
    call_handler: Incomplete
    exc: Incomplete
    def __init__(
        self, call_handler: Callable[[dict, list, dict], dict], params: dict, objs: list
    ) -> None: ...
    def enter(self, name, context) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *exc) -> None: ...

def concurrently(*objs, **kws): ...
def sequentially(*objs, **kws): ...

class ThreadDelegate:
    def __init__(self, sandbox, obj, dir_, repr_) -> None: ...
    def __call__(self, *args, **kws): ...
    def __getattribute__(self, name): ...
    def __dir__(self): ...
    def __setattr__(self, name, value): ...

class ThreadSandbox:
    __repr_root__: str
    __dir_root__: Incomplete
    def __init__(
        self, factory, should_sandbox_func: Incomplete | None = ...
    ) -> None: ...
    def __getattr__(self, name): ...
    def __setattr__(self, name, value): ...
    def __del__(self) -> None: ...
    def __dir__(self): ...

class ConfigStore:
    @classmethod
    def all(cls): ...
    @classmethod
    def frame(cls): ...

class SingleThreadProducer:
    def __new__(cls, func): ...
    def __call__(self): ...

class TTLCache:
    timeout: Incomplete
    call_timestamp: Incomplete
    last_value: Incomplete
    def __init__(self, timeout) -> None: ...
    def __call__(self, func): ...

# Names in __all__ with no definition:
#   _force_full_traceback
