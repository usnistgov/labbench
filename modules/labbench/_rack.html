<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>labbench._rack &#8212; labbench vgit</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
<header class="nist-header">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>NIST Pages Template</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="labbench vgit">
  <link rel="canonical" href="../../">
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- Google Analytics -->
  <!--<script type="text/javascript" id="_fed_an_js_tag" src="http://www.nist.gov/js/federated-analytics.all.min.js?agency=NIST&subagency=mml&pua=UA-66610693-1&yt=true&exts=ppsx,pps,f90,sch,rtf,wrl,txz,m1v,xlsm,msi,xsd,f,tif,eps,mpg,xml,pl,xlt,c"></script> -->
  <!-- DAP Analytics -->
  <script type="text/javascript" id="_fed_an_ua_tag" src="https://dap.digitalgov.gov/Universal-Federated-Analytics-Min.js?agency=DOC&subagefncy=NIST&pua=UA-66610693-1&yt=true&exts=ppsx,pps,f90,sch,rtf,wrl,txz,m1v,xlsm,msi,xsd,f,tif,eps,mpg,xml,pl,xlt,c"></script>

  <!-- Custom CSS -->
  <link rel="stylesheet" href="../..//static/NISTStyle.css">
  <link rel="stylesheet" href="../..//static/NISTPages.css">

  <h1>
    <a class="nist-logo" target="_blank" href="http://www.nist.gov/" title="Go to nist.gov">National Institute of Standards and Technology</a>
  </h1>
  <div class="nist-links">
    <a class="nist-links-button" target="_blank" href="http://www.nist.gov">NIST Website</a>
    <a class="nist-links-button mobile-hide" target="_blank" href="http://www.nist.gov/public_affairs/nandyou.cfm">About NIST</a>
    <a class="nist-links-button mobile-hide" target="_blank" href="https://github.com/usnistgov">usnistgov on GitHub</a>
  </div>
  
  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</header>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../labbench.html">labbench vgit</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">labbench._rack</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for labbench._rack</h1><div class="highlight"><pre>
<span></span><span class="c1"># This software was developed by employees of the National Institute of</span>
<span class="c1"># Standards and Technology (NIST), an agency of the Federal Government.</span>
<span class="c1"># Pursuant to title 17 United States Code Section 105, works of NIST employees</span>
<span class="c1"># are not subject to copyright protection in the United States and are</span>
<span class="c1"># considered to be in the public domain. Permission to freely use, copy,</span>
<span class="c1"># modify, and distribute this software and its documentation without fee is</span>
<span class="c1"># hereby granted, provided that this notice and disclaimer of warranty appears</span>
<span class="c1"># in all copies.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &#39;AS IS&#39; WITHOUT ANY WARRANTY OF ANY KIND, EITHER</span>
<span class="c1"># EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY</span>
<span class="c1"># THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM</span>
<span class="c1"># INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE</span>
<span class="c1"># SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE. IN NO EVENT</span>
<span class="c1"># SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT,</span>
<span class="c1"># INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM,</span>
<span class="c1"># OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON</span>
<span class="c1"># WARRANTY, CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED</span>
<span class="c1"># BY PERSONS OR PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED</span>
<span class="c1"># FROM, OR AROSE OUT OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES</span>
<span class="c1"># PROVIDED HEREUNDER. Distributions of NIST software should also include</span>
<span class="c1"># copyright and licensing statements of any third-party software that are</span>
<span class="c1"># legally bundled with the code in compliance with the conditions of those</span>
<span class="c1"># licenses.</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">ctypes</span> <span class="kn">import</span> <span class="n">ArgumentError</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_device</span> <span class="k">as</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util</span> <span class="k">as</span> <span class="n">util</span>

<span class="n">EMPTY</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">null_context</span><span class="p">(</span><span class="n">owner</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">owner</span>


<span class="k">class</span> <span class="nc">NeverRaisedException</span><span class="p">(</span><span class="ne">BaseException</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="n">_INSPECT_SKIP_PARAMETER_KINDS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="c1"># remember only named keywords, not &quot;*args&quot; and &quot;**kwargs&quot; in call signatures</span>
    <span class="n">inspect</span><span class="o">.</span><span class="n">_ParameterKind</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">,</span>
    <span class="n">inspect</span><span class="o">.</span><span class="n">_ParameterKind</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_filter_signature_parameters</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_INSPECT_SKIP_PARAMETER_KINDS</span>
    <span class="p">}</span>


<span class="k">class</span> <span class="nc">notify</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Singleton notification handler shared by all Rack instances&quot;&quot;&quot;</span>

    <span class="c1"># the global mapping of references to notification callbacks</span>
    <span class="n">_handlers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">calls</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">iteration</span><span class="o">=</span><span class="nb">set</span><span class="p">())</span>

    <span class="n">_owner_hold_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">returns</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">calls</span><span class="o">=</span><span class="nb">set</span><span class="p">(),</span> <span class="n">iteration</span><span class="o">=</span><span class="nb">set</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">hold_owner_notifications</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">owners</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">owners</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_owner_hold_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">allow_owner_notifications</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">owners</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">owners</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_owner_hold_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">return_event</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">returned</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">owner</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_owner_hold_list</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">returned</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;returned data was </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">returned</span><span class="p">)</span><span class="si">}</span><span class="s2">, which is not a dict&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;returns&quot;</span><span class="p">]:</span>
            <span class="n">handler</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">owner</span><span class="o">.</span><span class="n">_owned_name</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="n">owner</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">returned</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">call_event</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">owner</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_owner_hold_list</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;parameters data was </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span><span class="si">}</span><span class="s2">, which is not a dict&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;calls&quot;</span><span class="p">]:</span>
            <span class="n">handler</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">owner</span><span class="o">.</span><span class="n">_owned_name</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="n">owner</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">parameters</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">call_iteration_event</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">step_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">total_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">owner</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_owner_hold_list</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;iteration&quot;</span><span class="p">]:</span>
            <span class="n">handler</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">owner</span><span class="o">.</span><span class="n">_owned_name</span><span class="p">,</span>
                    <span class="n">owner</span><span class="o">=</span><span class="n">owner</span><span class="p">,</span>
                    <span class="n">old</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">new</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">step_name</span><span class="o">=</span><span class="n">step_name</span><span class="p">,</span> <span class="n">total_count</span><span class="o">=</span><span class="n">total_count</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">observe_returns</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not callable&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;returns&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">observe_calls</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not callable&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;calls&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">observe_call_iteration</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not callable&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;iteration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">unobserve_returns</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not callable&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;returns&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">unobserve_calls</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not callable&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;calls&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">unobserve_call_iteration</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not callable&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_handlers</span><span class="p">[</span><span class="s2">&quot;iteration&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CallSignatureTemplate</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>

    <span class="k">def</span> <span class="nf">get_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">):</span>
            <span class="c1"># might have no signature yet if it has not been claimed by its owner</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">target</span> <span class="o">=</span> <span class="n">owner</span><span class="o">.</span><span class="n">_ownables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">target</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;_owned_name&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;__name__&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; is not callable&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">target</span>

    <span class="k">def</span> <span class="nf">get_keyword_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">skip_names</span><span class="p">):</span>
        <span class="n">template_sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_target</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>
        <span class="c1"># template_sig = inspect.signature(template_sig.bind(owner))</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">p</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">template_sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_names</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,)</span>
        <span class="p">}</span>


<span class="k">class</span> <span class="nc">MethodTaggerDataclass</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;subclasses decorated with @dataclass will operate as decorators that stash annotated keywords here into the pending attribute dict&quot;&quot;&quot;</span>

    <span class="n">pending</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pending</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">rack_input_table</span><span class="p">(</span><span class="n">MethodTaggerDataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tag a method defined in a Rack to support execution from a flat table.</span>

<span class="sd">    In practice, this often means a very long argument list.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        table_path: location of the input table</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_path</span><span class="p">:</span> <span class="nb">str</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">rack_kwargs_template</span><span class="p">(</span><span class="n">MethodTaggerDataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tag a method defined in a Rack to replace a **kwargs argument using the signature of the specified callable.</span>

<span class="sd">    In practice, this often means a very long argument list.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        callable_template: replace variable keyword arguments (**kwargs) with the keyword arguments defined in this callable</span>

<span class="sd">        skip: list of column names to omit</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">template</span><span class="p">:</span> <span class="nb">callable</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">rack_kwargs_skip</span><span class="p">(</span><span class="n">MethodTaggerDataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tag a method defined in a Rack to replace a **kwargs argument using the signature of the specified callable.</span>

<span class="sd">    In practice, this often means a very long argument list.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        callable_template: replace variable keyword arguments (**kwargs) with the keyword arguments defined in this callable</span>

<span class="sd">        skip: list of column names to omit</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">skip</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg_names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip</span> <span class="o">=</span> <span class="n">arg_names</span>


<span class="k">class</span> <span class="nc">RackMethod</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;a wrapper that is applied behind the scenes in Rack classes to support introspection&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">kwdefaults</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># def ownable(obj, name):</span>
        <span class="c1">#     return isinstance(getattr(self._owner, name), util.Ownable)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">owner</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># overwrite the namespace with tags from the table input</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="n">MethodTaggerDataclass</span><span class="o">.</span><span class="n">pending</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">RackMethod</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_wrapped</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwdefaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_kwdefaults</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callable_template</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_callable_template</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">tags</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwdefaults</span> <span class="o">=</span> <span class="n">kwdefaults</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callable_template</span> <span class="o">=</span> <span class="n">CallSignatureTemplate</span><span class="p">(</span><span class="n">tags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="n">tags</span>

        <span class="c1"># self.__call__.__name__  = self.__name__ = obj.__name__</span>
        <span class="c1"># self.__qualname__ = obj.__qualname__</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_signature</span><span class="p">()</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate_from_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;call the BoundSequence for each row in a csv table.</span>
<span class="sd">        keyword argument names are taken from the column header</span>
<span class="sd">        (0th row). keyword values are taken from corresponding column in</span>
<span class="sd">        each row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

        <span class="n">table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_owned_name</span><span class="si">}</span><span class="s2"> from &#39;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;- &#39;</span><span class="si">{</span><span class="n">row</span><span class="si">}</span><span class="s2">&#39; (</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">call_iteration_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="o">**</span><span class="n">table</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="n">debug</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make a new RackMethod instance by copying another&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RackMethod</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="n">_kwdefaults</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__owner_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner_cls</span><span class="p">):</span>
        <span class="c1"># allow the owner class a chance to set up self.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__owner_subclass__</span><span class="p">(</span><span class="n">owner_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_signature</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_apply_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;updates self.__signature__</span>

<span class="sd">        __owner_subclass__ must have been called first to do introspection on self._callable_template.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">copy_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>

        <span class="c1"># note the devices needed to execute this function</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="n">Rack</span><span class="p">):</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="s2">&quot;__annotations__&quot;</span><span class="p">,</span> <span class="p">{})</span>

            <span class="c1"># set logic to identify Device dependencies</span>
            <span class="n">available</span> <span class="o">=</span> <span class="p">{</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">}</span>

            <span class="n">accessed</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">accessed_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="n">available</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">accessed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># get the signature, apply parameter defaults from self._kwdefaults</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="c1"># replace the **kwargs with specific keywords from the template function</span>
        <span class="n">skip_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;skip&quot;</span><span class="p">,</span> <span class="p">[]))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callable_template</span><span class="o">.</span><span class="n">get_target</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kws_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">param</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;cannot apply keyword arguments template to &quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_owned_name</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot;, which does not accept keyword arguments&#39;</span>
                <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">template_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callable_template</span><span class="o">.</span><span class="n">get_keyword_parameters</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="n">skip_param_names</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">skip_param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kws_name</span><span class="p">)</span>

                <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">template_params</span><span class="p">)</span>

        <span class="c1"># apply updated defaults</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">parameters</span><span class="o">=</span><span class="p">(</span>
                <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwdefaults</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_param_names</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># set the call signature shown by help(), or with ? in ipython/jupyter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="c1"># remember only named keywords, not &quot;*args&quot; and &quot;**kwargs&quot; in call signatures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_filter_signature_parameters</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">set_kwdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">new_default</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwdefaults</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_default</span>

        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># if there was no default before, delete now to bump this</span>
        <span class="c1"># parameter the end of the dictionary. this ensures no</span>
        <span class="c1"># default-less parameters come before default parameters.</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">EMPTY</span> <span class="ow">and</span> <span class="n">new_default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">EMPTY</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">)</span>
        <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">new_default</span><span class="p">)</span>

        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="c1"># if value is EMPTY:</span>
        <span class="c1">#     self._kwdefaults.pop(name, None)</span>
        <span class="c1"># elif name not in self.__signature__.parameters:</span>
        <span class="c1">#     raise TypeError(f&quot;{self} has no keyword argument {repr(name)}&quot;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self._kwdefaults[name] = value</span>

        <span class="c1"># self._introspect()</span>

        <span class="c1"># if value is EMPTY:</span>
        <span class="c1">#     del self._kwdefaults[name]</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self._kwdefaults[name] = value</span>

        <span class="c1"># self.introspect()</span>

    <span class="k">def</span> <span class="nf">extended_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_map</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;maps extended keyword argument names into a copy of self.__call__.__signature__&quot;&quot;&quot;</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span>
        <span class="n">ext_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_arguments</span><span class="p">(</span><span class="n">name_map</span><span class="p">)</span>

        <span class="n">param_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_filter_signature_parameters</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">parameters</span><span class="o">=</span><span class="p">[</span>
                <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ext_names</span><span class="p">,</span> <span class="n">param_list</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">extended_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_map</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;returns a list of argument names from in the owned context.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            name_map (dict): name remapping, overriding self.tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: should these all have &#39;owner&#39; as a name, to specify the context?</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">):</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">shared_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;shared_names&quot;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">name_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">shared_names</span><span class="p">,</span> <span class="n">shared_names</span><span class="p">)),</span> <span class="o">**</span><span class="n">name_map</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">name_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">hide_in_traceback</span>
    <span class="k">def</span> <span class="nf">call_by_extended_argnames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;rename keywords from the long form used by an owning class&quot;&quot;&quot;</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span>
        <span class="n">prefix_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>

        <span class="c1"># TODO: this will break in some keyword name edge-cases.</span>
        <span class="c1"># there should be an explicit dictionary mapping</span>
        <span class="c1"># into the extended arg name instead of guesswork</span>
        <span class="c1"># remove the leading name of the owner</span>
        <span class="n">kws</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">prefix_start</span><span class="p">:]</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="k">else</span> <span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kws</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kws</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># notify_params = {name_prefix + k: v for k, v in kws.items()}</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">call_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kws</span><span class="p">)</span>

        <span class="c1"># inspect.signature(self.__call__).bind(self, *args, **kws)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">hide_in_traceback</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="c1"># validate arguments against the signature</span>
        <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

        <span class="c1"># ensure that required devices are connected</span>
        <span class="c1"># TODO: let the devices handle this. some interactions with devices are necessary</span>
        <span class="c1"># and good without being connected, for example setting value traits.</span>
        <span class="c1"># closed = [dev._owned_name for dev in self.dependencies if not dev.isopen]</span>
        <span class="c1"># if len(closed) &gt; 0:</span>
        <span class="c1">#     closed = &quot;, &quot;.join(closed)</span>
        <span class="c1">#     raise ConnectionError(</span>
        <span class="c1">#         f&quot;devices {closed} must be connected to invoke {self.__qualname__}&quot;</span>
        <span class="c1">#     )</span>

        <span class="c1"># notify observers about the parameters passed</span>
        <span class="c1"># name_prefix = &quot;_&quot;.join((self._owner._owned_name or &quot;&quot;).split(&quot;.&quot;)[1:]) + &quot;_&quot;</span>
        <span class="c1"># if len(kws) &gt; 0:</span>
        <span class="c1">#     # notify_params = {name_prefix + k: v for k, v in kws.items()}</span>
        <span class="c1">#     notify.call_event(kws)</span>

        <span class="c1"># invoke the wrapped function</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="k">if</span> <span class="n">elapsed</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_owned_name</span><span class="si">}</span><span class="s2"> completed in </span><span class="si">{</span><span class="n">elapsed</span><span class="si">:</span><span class="s2">0.2f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

        <span class="c1"># notify observers about the returned value</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">need_notify</span> <span class="o">=</span> <span class="n">ret</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_owned_name</span><span class="p">:</span> <span class="n">ret</span><span class="p">}</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">return_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">need_notify</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wrapped</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">wrapped</span><span class="si">}</span><span class="s2"> wrapped by </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object&gt;&quot;</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> wrapper&gt;&quot;</span>


<span class="k">class</span> <span class="nc">BoundSequence</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;callable realization of a test sequence definition which</span>
<span class="sd">    takes the place of Sequence objects on instantiation of</span>
<span class="sd">    a new Rack object. its keyword arguments are aggregated</span>
<span class="sd">    from all of the methods called by the Sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cleanup_func</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">exception_allowlist</span> <span class="o">=</span> <span class="n">NeverRaisedException</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">hide_in_traceback</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># validate arguments against the signature</span>
        <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">notify</span><span class="o">.</span><span class="n">call_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sequence</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">):</span>
                <span class="n">step_kws</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

                <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="c1"># TODO: removing name metadata from each step removed a descriptive name here.</span>
                    <span class="c1"># add something back?</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__objclass__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">concurrently</span><span class="p">(</span><span class="o">**</span><span class="n">step_kws</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{})</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">exception_allowlist</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">core</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;exception&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_func</span><span class="p">()</span>

        <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__objclass__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span><span class="si">}</span><span class="s2">, finished)&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_template</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> template.csv&quot;</span>
        <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;writing csv template to </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">INDEX_COLUMN_NAME</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterate_from_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;call the BoundSequence for each row in a csv table.</span>
<span class="sd">        keyword argument names are taken from the column header</span>
<span class="sd">        (0th row). keyword values are taken from corresponding column in</span>
<span class="sd">        each row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

        <span class="n">table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_owned_name</span><span class="si">}</span><span class="s2"> from &#39;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;- &#39;</span><span class="si">{</span><span class="n">row</span><span class="si">}</span><span class="s2">&#39; (</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">call_iteration_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="p">(</span><span class="o">**</span><span class="n">table</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>

        <span class="n">available</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">shared_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;shared_names&quot;</span><span class="p">]</span>
        <span class="n">name_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">shared_names</span><span class="p">,</span> <span class="n">shared_names</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="c1"># make a Call object with the subset of `kwargs`</span>

            <span class="n">keys</span> <span class="o">=</span> <span class="n">available</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">extended_arguments</span><span class="p">(</span><span class="n">name_map</span><span class="o">=</span><span class="n">name_map</span><span class="p">))</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">call_by_extended_argnames</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="n">kws_out</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">_owner</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">kws_out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">kws_out</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;unsupported type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;in call sequence specification&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">kws_out</span>


<span class="k">class</span> <span class="nc">OwnerContextAdapter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;transform calls to __enter__ -&gt; open and __exit__ -&gt; close.</span>
<span class="sd">    each will be called</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owned_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="s2">&quot;_owned_name&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">owner</span><span class="p">))</span>
        <span class="c1"># display_name = getattr(self, &quot;_owned_name&quot;, type(self).__name__)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hold</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="o">.</span><span class="n">_ownables</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">RackMethod</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">hold_owner_notifications</span><span class="p">(</span><span class="o">*</span><span class="n">hold</span><span class="p">)</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">opener</span> <span class="ow">in</span> <span class="n">core</span><span class="o">.</span><span class="n">trace_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;open&quot;</span><span class="p">,</span> <span class="n">Owner</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">opener</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">)</span>

            <span class="c1"># self._owner.open()</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="s2">&quot;_logger&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;opened&quot;</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">allow_owner_notifications</span><span class="p">(</span><span class="o">*</span><span class="n">hold</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_info</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">holds</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="o">.</span><span class="n">_ownables</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">RackMethod</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">hold_owner_notifications</span><span class="p">(</span><span class="o">*</span><span class="n">holds</span><span class="p">)</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">)</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">trace_methods</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;close&quot;</span><span class="p">,</span> <span class="n">Owner</span><span class="p">)</span>

            <span class="n">all_ex</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">closer</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">closer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                    <span class="n">all_ex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">())</span>

            <span class="c1"># Print tracebacks for any suppressed exceptions</span>
            <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">all_ex</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># If ThreadEndedByMaster was raised, assume the error handling in</span>
                <span class="c1"># util.concurrently will print the error message</span>
                <span class="k">if</span> <span class="n">ex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">util</span><span class="o">.</span><span class="n">ThreadEndedByMaster</span><span class="p">:</span>
                    <span class="n">depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">walk_tb</span><span class="p">(</span><span class="n">ex</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exception</span><span class="p">(</span><span class="o">*</span><span class="n">ex</span><span class="p">,</span> <span class="n">limit</span><span class="o">=-</span><span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="c1"># sys.stderr.write(&quot;(Exception suppressed to continue close)\n\n&quot;)</span>

            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="s2">&quot;_logger&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;closed&quot;</span><span class="p">)</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="n">notify</span><span class="o">.</span><span class="n">allow_owner_notifications</span><span class="p">(</span><span class="o">*</span><span class="n">holds</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_ex</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">ConcurrentException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;multiple exceptions while closing </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">ex</span><span class="o">.</span><span class="n">thread_exceptions</span> <span class="o">=</span> <span class="n">all_ex</span>
                <span class="k">raise</span> <span class="n">ex</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owner</span><span class="p">,</span> <span class="s2">&quot;_owned_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">recursive_devices</span><span class="p">(</span><span class="n">top</span><span class="p">):</span>
    <span class="n">entry_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">_entry_order</span><span class="p">)</span>
    <span class="n">devices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">_devices</span><span class="p">)</span>
    <span class="n">name_prefix</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_prefix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">name_prefix</span> <span class="o">=</span> <span class="n">name_prefix</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>

    <span class="k">for</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">top</span><span class="o">.</span><span class="n">_owners</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">children</span><span class="p">,</span> <span class="n">o_entry_order</span> <span class="o">=</span> <span class="n">recursive_devices</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

        <span class="c1"># this might be faster by reversing key and value order in devices (and thus children)?</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">devices</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">devices</span><span class="p">[</span><span class="n">name_prefix</span> <span class="o">+</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span>

        <span class="n">entry_order</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">o_entry_order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">devices</span><span class="p">,</span> <span class="n">entry_order</span>


<span class="k">def</span> <span class="nf">flatten_nested_owner_contexts</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;generate a flattened mapping of context managers to</span>
<span class="sd">    that nested Owner classes</span>

<span class="sd">    Returns:</span>
<span class="sd">        mapping of {name: contextmanager}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">managers</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">owner</span> <span class="ow">in</span> <span class="n">top</span><span class="o">.</span><span class="n">_owners</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">managers</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">flatten_nested_owner_contexts</span><span class="p">(</span><span class="n">owner</span><span class="p">))</span>
        <span class="n">managers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">OwnerContextAdapter</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;&quot;</span> <span class="ow">in</span> <span class="n">managers</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">managers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">managers</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">_owned_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="s2">&quot;_owned_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">_owned_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">managers</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">OwnerContextAdapter</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">managers</span><span class="p">:</span>
        <span class="n">managers</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OwnerContextAdapter</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;unbound owners in the manager tree: </span><span class="si">{</span><span class="n">managers</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">_owned_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">managers</span>


<span class="k">def</span> <span class="nf">package_owned_contexts</span><span class="p">(</span><span class="n">top</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a context manager for an owner that also enters any Owned members</span>
<span class="sd">    (recursively) Entry into this context will manage all of these.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        top: top-level Owner</span>

<span class="sd">    Returns:</span>
<span class="sd">        Context manager</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">log</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="s2">&quot;_logger&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
    <span class="n">contexts</span><span class="p">,</span> <span class="n">entry_order</span> <span class="o">=</span> <span class="n">recursive_devices</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>

    <span class="c1"># like set(entry_order), but maintains order in python &gt;= 3.7</span>
    <span class="n">entry_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">entry_order</span><span class="p">))</span>
    <span class="n">order_desc</span> <span class="o">=</span> <span class="s2">&quot; -&gt; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entry_order</span><span class="p">])</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;entry_order before other devices: </span><span class="si">{</span><span class="n">order_desc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Pull any objects of types listed by top.entry_order, in the</span>
    <span class="c1"># order of (1) the types listed in top.entry_order, then (2) the order</span>
    <span class="c1"># they appear in objs</span>
    <span class="n">first</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">contexts</span><span class="p">)</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">entry_order</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">contexts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                <span class="n">first</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
    <span class="n">firsts_desc</span> <span class="o">=</span> <span class="s2">&quot;-&gt;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="c1"># then, other devices, which need to be ready before we start into Rack setup methods</span>
    <span class="n">devices</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">attr</span><span class="p">:</span> <span class="n">remaining</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Device</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">devices_desc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">devices</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="n">devices</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">concurrently</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">devices</span><span class="p">)</span>

    <span class="c1"># what remain are instances of Rack and other Owner types</span>
    <span class="n">owners</span> <span class="o">=</span> <span class="n">flatten_nested_owner_contexts</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
    <span class="n">owners_desc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">owners</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="c1"># TODO: concurrent rack entry. This would mean device dependency</span>
    <span class="c1"># checking to ensure avoid race conditions</span>
    <span class="c1"># owners = util.concurrently(name=&#39;&#39;, **owners) # &lt;- something like this</span>

    <span class="c1"># top._recursive_owners()</span>
    <span class="c1"># top._context.__enter__()</span>
    <span class="c1"># for child in top._owners.values():</span>
    <span class="c1">#     child.open()</span>
    <span class="c1"># top.open()</span>
    <span class="c1">#</span>
    <span class="c1"># the dictionary here is a sequence</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">devices</span> <span class="o">!=</span> <span class="p">{}:</span>
        <span class="n">seq</span><span class="p">[</span><span class="s2">&quot;_devices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">devices</span>
    <span class="n">seq</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">owners</span><span class="p">)</span>

    <span class="n">desc</span> <span class="o">=</span> <span class="s2">&quot;-&gt;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="n">firsts_desc</span><span class="p">,</span> <span class="n">devices_desc</span><span class="p">,</span> <span class="n">owners_desc</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;context order: </span><span class="si">{</span><span class="n">desc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">sequentially</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">top</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">seq</span><span class="p">)</span> <span class="ow">or</span> <span class="n">null_context</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">owner_getattr_chains</span><span class="p">(</span><span class="n">owner</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;recursively perform getattr on the given sequence of names&quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">{</span><span class="n">owner</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">()}</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">sub_owner</span> <span class="ow">in</span> <span class="n">owner</span><span class="o">.</span><span class="n">_owners</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># add only new changes (overwrite redundant keys with prior values)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">obj</span><span class="p">:</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span> <span class="o">+</span> <span class="n">chain</span>
                <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">owner_getattr_chains</span><span class="p">(</span><span class="n">sub_owner</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="o">**</span><span class="n">ret</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">Owner</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;own context-managed instances of Device as well as setup and cleanup calls to owned instances of Owner&quot;&quot;&quot;</span>

    <span class="n">_entry_order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_concurrent</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">entry_order</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># registries that will be context managed</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_devices</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># each of cls._devices.values() these will be context managed</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_owners</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">{}</span>
        <span class="p">)</span>  <span class="c1"># each of these will get courtesy calls to open and close between _device entry and exit</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_ownables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">entry_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entry_order</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Device</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;entry_order item </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2"> is not a Device subclass&quot;</span><span class="p">)</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_entry_order</span> <span class="o">=</span> <span class="n">entry_order</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_propagate_ownership</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_propagate_ownership</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_ownables</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># prepare and register owned attributes</span>
        <span class="n">attr_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">Owner</span><span class="p">))</span>

        <span class="c1"># don&#39;t use cls.__dict__ here since we also need parent attributes</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attr_names</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">need_copy</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">need_copy</span> <span class="o">=</span> <span class="n">copy</span>

            <span class="c1"># prepare these first, so they are available to owned classes on __owner_subclass__</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Device</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">need_copy</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_devices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Owner</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">need_copy</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_owners</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">_ownables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="c1"># run the hooks in owned classes, now that cls._devices and cls._owners are ready for them</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ownables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span>
                <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span>
            <span class="p">)</span>  <span class="c1"># in case it was originally instantiated outside cls</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">__owner_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="c1"># propagate_owned_names(cls, cls.__name__)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">update_ownables</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owners</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owners</span><span class="p">)</span>

        <span class="c1"># are the given objects ownable</span>
        <span class="n">unownable</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">obj</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">update_ownables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unownable</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;keyword argument objects </span><span class="si">{</span><span class="n">unownable</span><span class="si">}</span><span class="s2"> are not ownable&quot;</span><span class="p">)</span>

        <span class="c1"># update ownables</span>
        <span class="n">unrecognized</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">update_ownables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ownables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unrecognized</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">clsname</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__qualname__</span>
            <span class="n">unrecognized</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unrecognized</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;cannot update unrecognized attributes </span><span class="si">{</span><span class="n">unrecognized</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">clsname</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ownables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ownables</span><span class="p">,</span> <span class="o">**</span><span class="n">update_ownables</span><span class="p">)</span>

        <span class="c1"># update devices</span>
        <span class="n">update_devices</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">obj</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">update_ownables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Device</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">unrecognized</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">update_devices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_devices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unrecognized</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">clsname</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__qualname__</span>
            <span class="n">unrecognized</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unrecognized</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">clsname</span><span class="si">}</span><span class="s2"> Device attributes </span><span class="si">{</span><span class="n">unrecognized</span><span class="si">}</span><span class="s2"> can only be instantiated with Device objects&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_devices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_devices</span><span class="p">,</span> <span class="o">**</span><span class="n">update_devices</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owners</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__owner_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ownables</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># repeat this for Rack instances that are also Owners,</span>
            <span class="c1"># ensuring that obj._owned_name refers to the topmost</span>
            <span class="c1"># name</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">__owner_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># update naming for any util.Ownable instances</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ownables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__objclass__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__owner_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Device</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_devices</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Owner</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_owners</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">package_owned_contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__enter__</span><span class="o">.</span><span class="n">fget</span><span class="p">)</span>
        <span class="k">def</span> <span class="fm">__enter__</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>

            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="fm">__enter__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># pass along from self._context</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="fm">__exit__</span>


<span class="k">def</span> <span class="nf">override_empty</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;return no more than non-EMPTY value between two Parameter fields, otherwise raises TypeError&quot;&quot;&quot;</span>

    <span class="n">nonempty</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="n">EMPTY</span><span class="p">}</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonempty</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;conflicting </span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">nonempty</span><span class="si">}</span><span class="s2"> in aggregating argument &#39;</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonempty</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nonempty</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s2">&quot;annotation&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;type annotation &#39;</span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="s2">&#39; for parameter &#39;</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2">&#39; is not a class&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">EMPTY</span>


<span class="k">def</span> <span class="nf">update_parameter_dict</span><span class="p">(</span><span class="n">dest</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;updates the dest mapping with parameters taken from inspect.Signature.</span>

<span class="sd">    Items with the same name and defaults or annotations that are not EMPTY must be the same,</span>
<span class="sd">    or TypeError is raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pull a dictionary of signature values (default, annotation) with EMPTY as a null sentinel value</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="s2">&quot;parameters&quot;</span><span class="p">):</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">signature</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">signature</span><span class="o">.</span><span class="n">parameters</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="ow">is</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dest</span><span class="p">:</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">dest</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">annotation</span><span class="o">=</span><span class="n">override_empty</span><span class="p">(</span>
                    <span class="n">dest</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;annotation&quot;</span>
                <span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="n">override_empty</span><span class="p">(</span>
                    <span class="n">dest</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dest</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">attr_chain_to_method</span><span class="p">(</span><span class="n">root_obj</span><span class="p">,</span> <span class="n">chain</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;follows the chain with nested getattr calls to access the chain object&quot;&quot;&quot;</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">root_obj</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;_methods&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RackMethod</span><span class="o">.</span><span class="n">from_method</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_methods</span><span class="p">[</span><span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">RackMethod</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RackMethod</span><span class="o">.</span><span class="n">from_method</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">RackMethod</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">standardize_spec_step</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;standardizes the sequence specification dict to  {name: [list of methods]}&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="c1"># specification for a concurrent and/or sequential calls to RackMethod methods</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">RackMethod</span><span class="p">)):</span>
        <span class="c1"># a RackMethod method that is already packaged for use</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">sequence</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="c1"># it is a class method, just need to wrap it</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">RackMethod</span><span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="vm">__self__</span><span class="p">,</span> <span class="n">sequence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)]</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="s2">&quot;__wrapped__&quot;</span><span class="p">):</span>
        <span class="c1"># if it&#39;s a wrapper as implemented by functools, try again on the wrapped callable</span>
        <span class="k">return</span> <span class="n">standardize_spec_step</span><span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">__wrapped__</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span><span class="o">.</span><span class="vm">__qualname__</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;object of type &#39;</span><span class="si">{</span><span class="n">typename</span><span class="si">}</span><span class="s2">&#39; is neither a Rack method, Sequence, nor a nested tuple/list&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">sequence</span>


<span class="k">class</span> <span class="nc">Sequence</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An experimental procedure defined with methods in Rack instances. The input is a specification for sequencing these</span>
<span class="sd">    steps, including support for threading.</span>

<span class="sd">    Sequence are meant to be defined as attributes of Rack subclasses in instances of the Rack subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">access_spec</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cleanup_func</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">exception_allowlist</span> <span class="o">=</span> <span class="n">NeverRaisedException</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">specification</span><span class="p">,</span> <span class="n">shared_names</span><span class="o">=</span><span class="p">[],</span> <span class="n">input_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spec</span> <span class="o">=</span> <span class="p">[</span><span class="n">standardize_spec_step</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">specification</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">table_path</span><span class="o">=</span><span class="n">input_table</span><span class="p">,</span>
            <span class="n">shared_names</span><span class="o">=</span><span class="n">shared_names</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Sequence.return_on_exceptions"><a class="viewcode-back" href="../../labbench.html#labbench.Sequence.return_on_exceptions">[docs]</a>    <span class="k">def</span> <span class="nf">return_on_exceptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_or_exceptions</span><span class="p">,</span> <span class="n">cleanup_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Configures calls to the bound Sequence to swallow the specified exceptions raised by</span>
<span class="sd">        constitent steps. If an exception is swallowed, subsequent steps</span>
<span class="sd">        Sequence are not executed. The dictionary of return values from each Step is returned with</span>
<span class="sd">        an additional &#39;exception&#39; key indicating the type of the exception that occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception_allowlist</span> <span class="o">=</span> <span class="n">exception_or_exceptions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cleanup_func</span> <span class="o">=</span> <span class="n">cleanup_func</span></div>

    <span class="k">def</span> <span class="nf">__owner_subclass__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner_cls</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">extend_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">spec_entry</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">spec_entry</span><span class="o">.</span><span class="n">_owner</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;method &quot;</span><span class="si">{</span><span class="n">spec_entry</span><span class="o">.</span><span class="n">_owner</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">spec_entry</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&quot; in Sequence does not belong to a Rack&#39;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">chain</span><span class="p">[</span><span class="n">spec_entry</span><span class="o">.</span><span class="n">_owner</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">spec_entry</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">access_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># transform the objects in self.spec</span>
            <span class="c1"># into attribute names for dynamic access</span>
            <span class="c1"># in case of later copying and subclassing</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="n">owner_getattr_chains</span><span class="p">(</span><span class="n">owner_cls</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">access_spec</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">extend_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">]</span> <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__owner_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make a sequence bound to the owner&quot;&quot;&quot;</span>

        <span class="c1"># in case this is added through a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner_subclass__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">owner</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__owner_init__</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

        <span class="c1"># initialization on the parent class definition</span>
        <span class="c1"># waited until after __set_name__, because this depends on __name__ having been set for the tasks task</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">attr_chain_to_method</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">access_spec</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_spec</span> <span class="o">=</span> <span class="n">spec</span>

        <span class="c1"># build the callable object with a newly-defined subclass.</span>
        <span class="c1"># tricks ipython/jupyter into showing the call signature.</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">sequence</span><span class="o">=</span><span class="n">spec</span><span class="p">,</span>
            <span class="n">dependencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dependency_map</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span>
            <span class="n">cleanup_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cleanup_func</span><span class="p">,</span>
            <span class="n">exception_allowlist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exception_allowlist</span><span class="p">,</span>
            <span class="n">tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">,</span>
            <span class="vm">__name__</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="vm">__qualname__</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="vm">__objclass__</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__objclass__</span><span class="p">,</span>
            <span class="n">__owner_subclass__</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__owner_subclass__</span><span class="p">,</span>  <span class="c1"># in case the owner changes and calls this again</span>
        <span class="p">)</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">BoundSequence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">BoundSequence</span><span class="p">,),</span> <span class="n">ns</span><span class="p">)</span>

        <span class="c1"># Generate a signature for documentation and code autocomplete</span>
        <span class="c1"># params = [</span>
        <span class="c1">#     inspect.Parameter(&#39;self&#39;, kind=inspect.Parameter.POSITIONAL_ONLY),</span>
        <span class="c1"># ]</span>

        <span class="c1"># we need a wrapper so that __init__ can be modified separately for each subclass</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">copy_func</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span><span class="p">)</span>

        <span class="c1"># merge together</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">shared_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;shared_names&quot;</span><span class="p">]</span>
        <span class="n">name_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">shared_names</span><span class="p">,</span> <span class="n">shared_names</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">funcs</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                <span class="n">update_parameter_dict</span><span class="p">(</span>
                    <span class="n">params</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">extended_signature</span><span class="p">(</span><span class="n">name_map</span><span class="o">=</span><span class="n">name_map</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="fm">__call__</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># the testbed gets this BoundSequence instance in place of self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dependency_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">owner_deps</span><span class="o">=</span><span class="p">{})</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;maps the Device dependencies of each RackMethod in spec.</span>

<span class="sd">        Returns:</span>
<span class="sd">            {Device instance: reference to method that uses Device instance}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">deps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">owner_deps</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">RackMethod</span><span class="p">,</span> <span class="n">BoundSequence</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;expected RackMethod instance, but got &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">&#39; instead&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># race condition check</span>
                <span class="n">conflicts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">deps</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">dependencies</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conflicts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">users</span> <span class="o">=</span> <span class="p">{</span><span class="n">deps</span><span class="p">[</span><span class="n">device</span><span class="p">]</span> <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">conflicts</span><span class="p">}</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;risk of concurrent access to </span><span class="si">{</span><span class="n">conflicts</span><span class="si">}</span><span class="s2"> by </span><span class="si">{</span><span class="n">users</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">device</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">device</span> <span class="k">for</span> <span class="n">device</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">dependencies</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">deps</span>

    <span class="c1"># def _aggregate_signatures(self, spec) -&gt; inspect.Signature:</span>
    <span class="c1">#     &quot;&quot;&quot;aggregates calls from the Sequence specification into a Signature object</span>

    <span class="c1">#     Arguments:</span>
    <span class="c1">#         spec: nested list of calls that contains the parsed call tree</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     agg_params = dict(</span>
    <span class="c1">#         self=inspect.Parameter(&#39;self&#39;, kind=inspect.Parameter.POSITIONAL_ONLY)</span>
    <span class="c1">#     )</span>

    <span class="c1">#     # collect the defaults</span>
    <span class="c1">#     for funcs in spec.values():</span>
    <span class="c1">#         for func in funcs:</span>
    <span class="c1">#             merge_keyword_parameters(agg_params, func.extended_signature().parameters)</span>

    <span class="c1">#     return inspect.Signature(parameters=agg_params.values())</span>


<span class="k">class</span> <span class="nc">RackMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;metaclass for helpful exceptions&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;the `with` block needs an instance - &#39;with </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">():&#39; instead of &#39;with </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">:&#39;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_info</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Rack</span><span class="p">(</span><span class="n">Owner</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">Ownable</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">RackMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Rack provides context management and methods for groups of Device instances.</span>

<span class="sd">    The Rack object provides connection management for</span>
<span class="sd">    all devices and data managers for `with` block::</span>

<span class="sd">        with Rack() as testbed:</span>
<span class="sd">            # use the testbed here</span>
<span class="sd">            pass</span>

<span class="sd">    For functional validation, it is also possible to open only a subset</span>
<span class="sd">    of devices like this::</span>

<span class="sd">        testbed = Rack()</span>
<span class="sd">        with testbed.dev1, testbed.dev2:</span>
<span class="sd">            # use the testbed.dev1 and testbed.dev2 here</span>
<span class="sd">            pass</span>

<span class="sd">    The following syntax creates a new Rack class for an</span>
<span class="sd">    experiment:</span>

<span class="sd">        import labbench as lb</span>

<span class="sd">        class MyRack(lb.Rack):</span>
<span class="sd">            db = lb.SQLiteManager()</span>
<span class="sd">            sa = MySpectrumAnalyzer()</span>

<span class="sd">            spectrogram = Spectrogram(db=db, sa=sa)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">entry_order</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_entry_order</span> <span class="o">=</span> <span class="n">entry_order</span>

        <span class="c1"># register step methods</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_methods</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">attr_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">Owner</span><span class="p">)))</span>

        <span class="c1"># not using cls.__dict__ because it neglects parent classes</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attr_names</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Device</span><span class="p">,</span> <span class="n">Owner</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">BoundSequence</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_methods</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="c1"># include annotations from parent classes</span>
        <span class="bp">cls</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(),</span> <span class="s2">&quot;__annotations__&quot;</span><span class="p">,</span> <span class="p">{}),</span>
            <span class="o">**</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__annotations__&quot;</span><span class="p">,</span> <span class="p">{}),</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__annotations__</span>

        <span class="c1"># adjust the __init__ signature for introspection/doc</span>

        <span class="c1"># Generate a signature for documentation and code autocomplete</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="c1"># generate and apply the sequence of call signature parameters</span>
        <span class="n">params</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">EMPTY</span><span class="p">),</span>
                <span class="n">annotation</span><span class="o">=</span><span class="n">annot</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">annot</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__annotations__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="c1"># we need a wrapper so that __init__ can be modified separately for each subclass</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">copy_func</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="n">entry_order</span><span class="o">=</span><span class="n">entry_order</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">ownables</span><span class="p">):</span>
        <span class="c1"># new dict mapping object for the same devices</span>
        <span class="n">ownables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ownables</span><span class="p">)</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev</span> <span class="ow">in</span> <span class="n">ownables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># self.__annotations__.items():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dev_type</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">.__init__ was given invalid keyword argument &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_type</span><span class="p">):</span>
                <span class="c1"># allow the sentinel EMPTY to instantiate for introspection</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;argument &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is not an instance of &#39;</span><span class="si">{</span><span class="n">dev_type</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="p">)</span>

        <span class="c1"># check for a valid instance in the class for each remaining attribute</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dev_type</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">EMPTY</span><span class="p">),</span> <span class="n">dev_type</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">annotations</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># any remaining items in annotations are missing arguments</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;missing keyword arguments </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># now move forward with applying the devices</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">ownables</span><span class="p">)</span>

        <span class="c1"># wrap self._methods as necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">obj</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">RackMethod</span><span class="p">)</span> <span class="k">else</span> <span class="n">RackMethod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called when an owning class is subclassed&quot;&quot;&quot;</span>
        <span class="n">owners</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owners</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># steps = {name: copy.deepcopy(obj) for name, obj in type(self)._methods.items()}</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="vm">__annotations__</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">,</span>
            <span class="vm">__module__</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
            <span class="o">**</span><span class="n">owners</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># return self</span>
        <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">owners</span><span class="p">)</span>

        <span class="n">subcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),),</span> <span class="n">namespace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subcls</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_devices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__owner_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__owner_init__</span><span class="p">(</span><span class="n">owner</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s2">&quot;_methods&quot;</span> <span class="ow">and</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_methods</span><span class="p">)</span>


<span class="n">Rack</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_use_module_path</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="p">:]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>


<span class="k">def</span> <span class="nf">import_as_rack</span><span class="p">(</span>
    <span class="n">import_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="c1"># working_dir: str,</span>
    <span class="n">cls_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">append_path</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">base_cls</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">Rack</span><span class="p">,</span>
    <span class="n">replace_attrs</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;__doc__&quot;</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a Rack subclass with the specified module&#39;s contents. Ownable objects are annotated</span>
<span class="sd">    by type, allowing the resulting class to be instantiated.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        import_string: for the module that contains the Rack to import</span>

<span class="sd">        cls_name: the name of the Rack subclass to import from the module (or None to build a</span>
<span class="sd">                  new subclass with the module contents)</span>

<span class="sd">        base_cls: the base class to use for the new subclass</span>

<span class="sd">        append_path: list of paths to append to sys.path before import</span>

<span class="sd">        replace_attrs: attributes of `base_cls` to replace from the module</span>

<span class="sd">    Exceptions:</span>
<span class="sd">        NameError: if there is an attribute name conflict between the module and base_cls</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dynamically created subclass of base_cls</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isadaptable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;skip function, module, and type attributes&quot;&quot;&quot;</span>
        <span class="n">type_ok</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismodule</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># __name__ causes an undesired __name__ attribute to exist in the root Rack class</span>
        <span class="c1"># (this breaks logic that expects this to exist only in owned instances</span>
        <span class="n">name_ok</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">replace_attrs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">type_ok</span> <span class="ow">and</span> <span class="n">name_ok</span>

    <span class="c1"># start_dir = Path(&#39;.&#39;).absolute()</span>
    <span class="c1"># os.chdir(working_dir)</span>
    <span class="k">if</span> <span class="n">append_path</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">_use_module_path</span><span class="p">(</span><span class="n">append_path</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">import_string</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">import_string</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cls_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># work with the class specified in the module</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">cls_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">base_cls</span><span class="p">):</span>
            <span class="c1"># it&#39;s already a Rack instance - return it</span>
            <span class="k">return</span> <span class="bp">cls</span>
        <span class="k">elif</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismodule</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cls_name</span><span class="si">}</span><span class="s2"> is not a subclass of </span><span class="si">{</span><span class="n">base_cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">dunder_updates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cls_name</span> <span class="o">=</span> <span class="s2">&quot;__main__&quot;</span>

        <span class="n">dunder_updates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="vm">__module__</span><span class="o">=</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">__attributes__</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">base_cls</span><span class="p">,</span> <span class="s2">&quot;__attributes__&quot;</span><span class="p">,</span> <span class="p">{}),</span>
                <span class="o">**</span><span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="s2">&quot;__attributes__&quot;</span><span class="p">,</span> <span class="p">{}),</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="n">namespace</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># take namespace items that are not types or modules</span>
        <span class="n">attr</span><span class="p">:</span> <span class="n">obj</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">isadaptable</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1"># # annotate the rack, which sets up the constructor signature that we use for config</span>
    <span class="c1"># namespace[&quot;__annotations__&quot;] = {</span>
    <span class="c1">#         name: type(obj)</span>
    <span class="c1">#         for name, obj in namespace.items()</span>
    <span class="c1">#         if isinstance(obj, util.Ownable)</span>
    <span class="c1"># }</span>

    <span class="c1"># raise NameError on redundant names - overloading could be</span>
    <span class="c1"># very messy in this context</span>
    <span class="n">name_conflicts</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">base_cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">replace_attrs</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_conflicts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;names </span><span class="si">{</span><span class="n">name_conflicts</span><span class="si">}</span><span class="s2"> in module &#39;</span><span class="si">{</span><span class="n">module</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;conflict with attributes of &#39;</span><span class="si">{</span><span class="n">base_cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>

    <span class="n">namespace</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dunder_updates</span><span class="p">)</span>

    <span class="c1"># subclass into a new Rack</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="p">(</span><span class="n">base_cls</span><span class="p">,),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">base_cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span> <span class="o">**</span><span class="n">namespace</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">find_owned_rack_by_type</span><span class="p">(</span>
    <span class="n">parent_rack</span><span class="p">:</span> <span class="n">Rack</span><span class="p">,</span> <span class="n">target_type</span><span class="p">:</span> <span class="n">Rack</span><span class="p">,</span> <span class="n">include_parent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;return a rack instance of `target_type` owned by `parent_rack`. if there is</span>
<span class="sd">    not exactly 1 for `target_type`, TypeError is raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: add this to labbench</span>
    <span class="k">if</span> <span class="n">include_parent</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent_rack</span><span class="p">,</span> <span class="n">target_type</span><span class="p">):</span>
        <span class="n">target_rack</span> <span class="o">=</span> <span class="n">parent_rack</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">type_matches</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">obj</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">parent_rack</span><span class="o">.</span><span class="n">_ownables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="c1"># need to think about why the inheritance tree is broken here</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_type</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parent_rack</span><span class="si">}</span><span class="s2"> contains no racks of type </span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parent_rack</span><span class="si">}</span><span class="s2"> contains multiple racks </span><span class="si">{</span><span class="n">type_matches</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">target_rack</span><span class="p">,)</span> <span class="o">=</span> <span class="n">type_matches</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">target_rack</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../labbench.html">labbench vgit</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">labbench._rack</a></li> 
      </ul>
    </div>
<hr \>
<section class="footer">
<br><a target="_blank" href="http://www.nist.gov/public_affairs/privacy.cfm#privpolicy">Privacy Policy</a> | <a target="_blank" href="http://www.nist.gov/public_affairs/privacy.cfm#secnot">Security Notice</a> | <a href="http://www.nist.gov/public_affairs/privacy.cfm#accesstate">Accessibility Statement</a>
<br><em>United States government work, not subject to copyright in the United States</em>
</section>

  </body>
</html>